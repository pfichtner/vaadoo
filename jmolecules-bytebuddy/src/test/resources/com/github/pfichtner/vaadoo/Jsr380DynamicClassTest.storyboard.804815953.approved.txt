----------------------------------------------------------------
params annotations
- Jsr380DynamicClassTest.ParameterConfig(type=class java.time.chrono.HijrahDate, annotations=[interface jakarta.validation.constraints.Past, interface jakarta.validation.constraints.PastOrPresent])
- Jsr380DynamicClassTest.ParameterConfig(type=class java.time.Year, annotations=[interface jakarta.validation.constraints.PastOrPresent, interface jakarta.validation.constraints.Null])
- Jsr380DynamicClassTest.ParameterConfig(type=interface java.util.Map, annotations=[interface jakarta.validation.constraints.NotEmpty])
- Jsr380DynamicClassTest.ParameterConfig(type=boolean, annotations=[interface jakarta.validation.constraints.AssertFalse])
- Jsr380DynamicClassTest.ParameterConfig(type=class [Ljava.lang.Object;, annotations=[])
----------------------------------------------------------------
Analysing type com.example.Generated_804815953
/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  com.example.Generated_804815953$auxiliary$[AUX2_1]
 */
package com.example;

import com.example.Generated_804815953;
import jakarta.validation.constraints.AssertFalse;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Null;
import jakarta.validation.constraints.Past;
import jakarta.validation.constraints.PastOrPresent;
import java.time.Year;
import java.time.chrono.HijrahDate;
import java.util.Map;
import org.jmolecules.ddd.types.ValueObject;

public class Generated_804815953
implements ValueObject {
    public Generated_804815953(@Past(groups={}, message="{jakarta.validation.constraints.Past.message}", payload={}) @PastOrPresent(groups={}, message="{jakarta.validation.constraints.PastOrPresent.message}", payload={}) HijrahDate hijrahDate, @PastOrPresent(groups={}, message="{jakarta.validation.constraints.PastOrPresent.message}", payload={}) @Null(groups={}, message="{jakarta.validation.constraints.Null.message}", payload={}) Year year, @NotEmpty(groups={}, message="{jakarta.validation.constraints.NotEmpty.message}", payload={}) Map map, @AssertFalse(groups={}, message="{jakarta.validation.constraints.AssertFalse.message}", payload={}) boolean bl, Object[] objectArray) {
        Generated_804815953.validate(hijrahDate, year, map, bl, objectArray);
        this(hijrahDate, year, map, bl, objectArray, null);
    }

    private /* synthetic */ Generated_804815953(HijrahDate hijrahDate, Year year, Map map, boolean bl, Object[] objectArray, auxiliary.[AUX1_1 AUX1_1] {
    }

    private static void validate(HijrahDate hijrahDate, Year year, Map map, boolean bl, Object[] objectArray) {
        if (hijrahDate != null && !hijrahDate.isBefore(HijrahDate.now())) {
            throw new IllegalArgumentException("arg0 must be a past date");
        }
        if (hijrahDate != null && hijrahDate.isAfter(HijrahDate.now())) {
            throw new IllegalArgumentException("arg0 must be a date in the past or in the present");
        }
        if (year != null && year.isAfter(Year.now())) {
            throw new IllegalArgumentException("arg1 must be a date in the past or in the present");
        }
        if (year != null) {
            throw new IllegalArgumentException("arg1 must be null");
        }
        if (map == null) {
            throw new NullPointerException("arg2 must not be empty");
        }
        if (map.size() <= 0) {
            throw new IllegalArgumentException("arg2 must not be empty");
        }
        if (bl) {
            throw new IllegalArgumentException("arg3 must be false");
        }
    }
}


----------------------------------------------------------------
