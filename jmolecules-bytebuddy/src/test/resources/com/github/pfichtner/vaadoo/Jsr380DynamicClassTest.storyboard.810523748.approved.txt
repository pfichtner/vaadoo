----------------------------------------------------------------
params annotations
- TestClassBuilder.ParameterConfig(type=class java.time.LocalTime, annotations=[interface jakarta.validation.constraints.PastOrPresent, interface jakarta.validation.constraints.FutureOrPresent])
- TestClassBuilder.ParameterConfig(type=class java.time.MonthDay, annotations=[])
- TestClassBuilder.ParameterConfig(type=short, annotations=[])
- TestClassBuilder.ParameterConfig(type=class [Ljava.lang.Object;, annotations=[])
- TestClassBuilder.ParameterConfig(type=class java.time.Year, annotations=[])
----------------------------------------------------------------
Analysing type com.example.Generated_810523748
/*
 * Decompiled with CFR.
 */
package com.example;

import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.PastOrPresent;
import java.time.LocalTime;
import java.time.MonthDay;
import java.time.Year;
import org.jmolecules.ddd.types.ValueObject;

public class Generated_810523748
implements ValueObject {
    public Generated_810523748(@PastOrPresent(groups={}, message="{jakarta.validation.constraints.PastOrPresent.message}", payload={}) @FutureOrPresent(groups={}, message="{jakarta.validation.constraints.FutureOrPresent.message}", payload={}) LocalTime localTime, MonthDay monthDay, short s, Object[] objectArray, Year year) {
    }
}


----------------------------------------------------------------
Analysing type com.example.Generated_810523748
/*
 * Decompiled with CFR.
 */
package com.example;

import com.example.Generated_810523748;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.PastOrPresent;
import java.time.LocalTime;
import java.time.MonthDay;
import java.time.Year;
import org.jmolecules.ddd.types.ValueObject;

public class Generated_810523748
implements ValueObject {
    public Generated_810523748(@PastOrPresent(groups={}, message="{jakarta.validation.constraints.PastOrPresent.message}", payload={}) @FutureOrPresent(groups={}, message="{jakarta.validation.constraints.FutureOrPresent.message}", payload={}) LocalTime localTime, MonthDay monthDay, short s, Object[] objectArray, Year year) {
        Generated_810523748.validate(localTime, monthDay, s, objectArray, year);
        this(localTime, monthDay, s, objectArray, year, null);
    }

    private /* synthetic */ Generated_810523748(LocalTime localTime, MonthDay monthDay, short s, Object[] objectArray, Year year, auxiliary.[AUX1_1 AUX1_1] {
    }

    private static void validate(LocalTime localTime, MonthDay monthDay, short s, Object[] objectArray, Year year) {
        if (localTime != null && localTime.isAfter(LocalTime.now())) {
            throw new IllegalArgumentException("localTime must be a date in the past or in the present");
        }
        if (localTime != null && localTime.isBefore(LocalTime.now())) {
            throw new IllegalArgumentException("localTime must be a date in the present or in the future");
        }
    }
}


----------------------------------------------------------------