Story:
regexp

params annotations
-: TestClassBuilder.DefaultParameterDefinition(typeDefinition=TestClassBuilder.TypeDefinition(type=class java.lang.String, genericType=null, genericTypeAnnotations=[]), annotations=[TestClassBuilder.AnnotationDefinition(annotation=interface jakarta.validation.constraints.Pattern, values={regexp=\d*})])


Source:
Analysing type com.example.Generated
/*
 * Decompiled with CFR.
 */
package com.example;

import jakarta.validation.constraints.Pattern;
import org.jmolecules.ddd.types.ValueObject;

public class Generated
implements ValueObject {
    public Generated(@Pattern(flags={}, groups={}, message="{jakarta.validation.constraints.Pattern.message}", payload={}, regexp="\d*") String string) {
    }
}



Transformed:
Analysing type com.example.Generated
/*
 * Decompiled with CFR.
 */
package com.example;

import com.example.Generated;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;
import org.jmolecules.ddd.types.ValueObject;

public class Generated
implements ValueObject {
    private static final /* synthetic */ Map regexpCache;

    public Generated(String string) {
        Generated.validate(string);
        this(string, null);
    }

    private /* synthetic */ Generated(String string, auxiliary.[AUX1_1 AUX1_1] {
    }

    private static void validate(String string) {
        if (string != null && !Generated.getCachedPattern("\\d*", 0).matcher(string).matches()) {
            throw new IllegalArgumentException("string must match \"\\d*\"");
        }
    }

    static {
        regexpCache = new ConcurrentHashMap();
    }

    private static /* synthetic */ Pattern getCachedPattern(String string, int n) {
        String string2 = string + "\u0000" + n;
        return regexpCache.computeIfAbsent(string2, object -> Pattern.compile(string, n));
    }
}

